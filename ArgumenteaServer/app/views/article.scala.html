@(article: Article, annotations: List[Annotation], annotationForm: Form[Annotation])

@import helper._

@main(article.getTitle) {

<div id="zoneAnnotable">  
  <h1>@article.getTitle</h1>
  

  <div class="ResourceContent" id="article-@article.getId">
  	@Html(article.getContent)
  </div>

	<div class="author">
		@article.getAuthor.getNickname
	</div>

</div>	
	<button class="btn btn-select" type ="button">Sélectionner</button>
	
	<h2>Annotations : </h2>
	<ul>
    @for(annotation <- annotations) {
      <li><a href="@routes.UserProfile.annotation(annotation.getId.toString)">Porte sur : @annotation.getAnnotated.getTitle</a>
      <div class="content">@Html(annotation.getContent)</div>
      <div class="annotatedContent">@Html(annotation.getAnnotatedContent)</div>
      @form(routes.UserProfile.deleteAnnotation(annotation.getId.toString)) {
                    <input type="submit" value="Delete">
                }
      </li>
    }
  </ul>
}

<script type="text/javascript">
$(document).ready(function($){
	
	$("body").ajaxError(function(event, jqXHR, ajaxSettings, thrownError){
            alert("ERROR : " + thrownError);
            location.reload();
        });
        
    	$btnSelect = $(".btn-select");

	//Pour récupérer une sélection, un contenu et deux xpointers
	$btnSelect.click(function(event) {
	 	alert("click");
		//recuperation de la selection en cours
        	var selection = window.getSelection();
		//vérifier que la sélection n'est pas vide
		if(selection.toString().length > 0)
                {
			var content = selection.toString();
			var currentUrl = window.location;
			alert("content : " + content);
			alert("currentUrl : " + currentUrl);
			//Test du Browser
			//TODO
			//XPOINTER Mozilla
			var xpointerStart;
                        var xpointerEnd;
                        
                        //Noeuds du début et de la fin de la selection
                        var start_node = selection.anchorNode;//selection.startContainer;
                        var end_node = selection.focusNode;//selection.endContainer;
			//alert("start_node" + start_node);
        		//alert("end_node :" + end_node );                        
                        //Le nombre de caractere entre le noeud pere et le debut/fin de la selection
                        var start_offset = selection.anchorOffset; // NE TIENT PAS COMPTE DES CARACTERES HTML PRESENTS AVANT LA SELECTION JUSQU'AU NOEUD PERE
                        var end_offset = selection.focusOffset;
                        
			//Corrections des noeuds de départ et de fin        
                        var trueStartNode = start_node ;
                        var trueEndNode = end_node;
                            
                        /*Firefox ajoute des noeuds text pour entourer du texte, quand le noeud pere est du type text, 
                        *on reccupere le pere du noeud text
                        **/
                        if(start_node.nodeType == 3)
                        {
                        	trueStartNode = start_node.parentNode ;
                        }
                        if(end_node.nodeType == 3)
                        {
                        	trueEndNode = end_node.parentNode;
                        }
                                
                        //echange trueStartNode et trueEndNode quand le cas ou on fait une selection inversé (on commence de la fin)
                        //cas ou le noeud de depart precede le noeud d'arrive
                        //ou bien le noeud de depart est contenu dans le noeud d'arrive 
                        if(trueStartNode.compareDocumentPosition(trueEndNode) == 2 || 
                           trueStartNode.compareDocumentPosition(trueEndNode) == 10)
                        {
                        	var tmp = trueStartNode;
                        	trueStartNode = trueEndNode;
                        	trueEndNode = tmp;
		                tmp = start_offset;
		                start_offset = end_offset;
		                end_offset = tmp;
                        }
                        //cas ou on fait une selection inversé dans une meme balise
                        else if(trueStartNode.compareDocumentPosition(trueEndNode) == 0 && start_offset > end_offset)
                        {
		                var tmp = start_offset;
		                start_offset = end_offset;
		                end_offset = tmp;
                        }
			//vérifier que les deux noeuds sont bien dans une zone annotable (fils du noeud d'id : zoneAnnotable)
			var testStart = testAnnotable(trueStartNode);
			if(testStart)
			{
				var testEnd = testAnnotable(trueEndNode);
				if(testEnd)
				{
				        xpointerStart = makeXpointer(currentUrl, trueStartNode, start_offset);
				        xpointerEnd = makeXpointer(currentUrl, trueEndNode, end_offset);
					alert(xpointerStart);
				        alert(xpointerEnd);
				}
				else alert("sélection non valide");
			}
			else alert("sélection non valide");
		}
	});
			/*
			* Vérifie que le noeud est bien un fils du noeud d'id zoneAnnotable
			**/
			function testAnnotable(node)
			{
				//alert("testAnnotable : " + node);
				while(node.id != "zoneAnnotable")
				{
					node = node.parentNode ;
					if(node.nodeName == 'BODY') return false ;
				}
				return true ;
			}

		            /*
                             *
                             *Format d'un xPointer: 
                             *url_courant#xpointer(id('idNoeudPere')/chemin/des/peres, nbCaractereEntreNoeudEtSelection)
                             *ou si on ne trouve pas d'id de reference:
                             *url_courant#xpointer(body/chemin/des/peres, nbCaractereEntreNoeudEtSelection)
                             *
                             **/
                            
                            //parametre: url courant, node de depart pour le calcul du xpointer et le offset (nb caractere entre node et le debut de la selection)
                            function makeXpointer(url, node, offset)
                            {
                                var xpointer = url+"#xpointer(";
                               // var idNode = -1;
				var idNode = node.id;
                                var path = "";
                                var nbPreviousSiblings = 0;
                                var previousNode;
                                //alert("calcul XPOINTER : nodeName avant while : " + node.nodeName);
                                //tant qu'on ne trouve pas de noeud avec un id
                                while(idNode == "" || idNode == -1)
                                {
				    //alert("calcul XPOINTER : nodeName while : " + node.nodeName);
				    //alert("calcul XPOINTER : idNode : " + idNode);
                                    previousNode = node;
                                    //calcul de la position du noeud actuel par rapport a son pere
                                    nbPreviousSiblings = $(previousNode).prevAll().length;
                                    path = "/" + nbPreviousSiblings + path;
                                    node = previousNode.parentNode;
                                    
                                    //si le noeud actuel est la balise body on break la boucle car on est arrivé au bout sans trouver d'id
                                    if(node.nodeName == 'BODY')
				    {
                                        break;
                                    } 
				   idNode = node.id;
				   //alert("calcul XPOINTER : change idNode");
                                }
                                if(node.nodeName == 'BODY')
                                {
                                    xpointer = xpointer + "body"
                                }
                                else
                                {
                                    xpointer = xpointer + "id(\"" + idNode + "\")";
                                }
                                xpointer = xpointer + path + "," + offset + ")";
                                return xpointer;
                            }

});
</script>
